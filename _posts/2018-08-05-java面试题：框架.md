---
layout: post
title: "Java面试题：框架"
date: 2018-8-5 
description: "Java面试题 框架"
tag: Java面试题 
---   

## Java面试题：框架

-----

### 1.hibernate的get()和load()方法的去别?

- **返回值：**

  get()返回的是查询出来的实体对象，而 load()查询出来的是一个目标实体的代理对象。

- **查询时机：**

  get()在调用的时候就立即发出 SQL 语句查询，而 load()在访问非 ID 属性的时候才会发出查询语句并且将被代理对象 target 填充上，但是如果这个动作发生在 Session 被关闭后的话就会抛出 LazyInitializationException。

- **查询结果为空时：**

  get()抛出 NullPointerException
  load()抛出 ObjectNotFoundException

------

### 2.描述spring中的编程式事务处理和声明式事务处理

编程式事务需要你在代码中直接加入处理事务的逻辑,可能需要在代码中显式调beginTransaction()、 commit()、 rollback()等事务管理相关的方法,如在执行 a 方法时候需要事务处理,你需要在 a 方法开始时候开启事务,处理完后。在方法结束时候,关闭事务。

声明式的事务的做法是在 a 方法外围添加注解或者直接在配置文件中定义,a 方法需要事务处理,在spring 中会通过配置文件在 a 方法前后拦截,并添加事务。

**二者区别：**编程式事务侵入性比较强，但处理粒度更细。

------

### 3.spring 设置为单例，线程安全问题怎么解决？

spring 的单例和我们设计模式中的单例还是有些区别的，设计模式中的单例是在整个应用中只存在一个单例，而 spring 中的单例是存在 IOC 容器中只有一个实例， spring 中的单例并不会影响到应用的并发访问，通常我们 spring中的线程安全问题是指的在业务逻辑中的那个问题， ThreadLocal 则从另一个角度来解决多线程的并发访问。 

ThreadLocal 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。 ThreadLocal 提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。

------

### 4.struts 可以是单例的吗？ 为什么？

在 Struts2 中 action 必须为多例，主要原因在于请求数据和返回数据大部分封装到了 action 中，用于实例化变量，这样以来，如果将 action 设置成单例模式，则多个线程访问的时候，就会共享这些数据，从而引起数据混乱或者线程安全问题！

------

### 5.SpringMVC 工程流程

1. 用户向服务器发送请求，请求被 Spring 前端控制ServeltDispatcherServlet 捕获；
2. DispatcherServlet 对请求 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回；
3. DispatcherServlet 根据获得的 Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得 HandlerAdapter 后，此时将开始执行拦截器的 preHandler(...)方法）
4. 提取 Request 中的模型数据，填充 Handler 入参，开始执行 Handler（Controller)。 在填充 Handler 的入参过程中，根据你的配置， Spring 将帮你做一些额外的工作：
   1. **HttpMessageConveter：**将请求消息（如 Json、 xml 等数据）转换成一个对象，将对象转换为指定的响应信息
   2. **数据转换：**对请求消息进行数据转换。如 String 转换成 Integer、 Double 等
   3. **数据根式化：**对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等
   4. **数据验证：** 验证数据的有效性（长度、格式等），验证结果存储到BindingResult 或 Error 中
5. Handler 执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象；
6. 根据返回的 ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的 ViewResolver)返回给 DispatcherServlet ；
7. ViewResolver 结合 Model 和 View，来渲染视图
8. 将渲染结果返回给客户端

------

### 6.hibernate 的懒加载有几种禁用方法？

在 Hibernate 框架中，当我们要访问的数据量过大时，明显用缓存不太合适，因为内存容量有限 ，为了减少并发量，减少系统资源的消耗，这时Hibernate 用懒加载机制来弥补这种缺陷，但是这只是弥补而不是用了懒加载总体性能就提高了。

我们所说的懒加载也被称为延迟加载，它在查询的时候不会立刻访问数据库，而是返回代理对象，当真正去使用对象的时候才会访问数据库。

1. 使用代理对象： Hibernate.initialize("代理对象");
2. 在需要禁用懒加载的映射文件中显示的加入 lazy = "false"
3. 使用 openSessionInView【需要借助于过滤器】 需要在 web.xml 文件中配置

------

### 7.Hibernate 工作原理及为什么要用？

**原理:**

1. 读取并解析配置文件
2. 读取并解析映射信息
3. 创建 SessionFactory
4. 打开 Sesssion
5. 创建事务 Transation
6. 持久化操作
7. 提交事务
8. 关闭 Session
9. 关闭 SesstionFactory

**为什么要用**

1. 对 JDBC 访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。
2. Hibernate 是一个基于 JDBC 的主流持久化框架，是一个优秀的 ORM 实现，他很大程度的简化 DAO 层的编码工作。
3. hibernate 使用 Java 反射机制，而不是字节码增强程序来实现透明性。
4. hibernate 的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。







-----------------------------

转载请注明原地址，宋德凌的博客：[http://CoderOfSong.github.io](http://CoderOfSong.github.io) 谢谢！