---
layout: post
title: "Java面试题：数据库"
date: 2018-8-5 
description: "面试题 数据库"
tag: Java面试题 
---   

## Java面试题：数据库

-----

### 1. 说一下对多线程死锁的理解，举个例子，说一下什么情况下会出现死锁？

举个生活中的例子：有一座桥很窄，一次只能通过一辆汽车，可现在有 A 和B 两辆汽车分别从桥的两端已经驶进了桥，也就是两辆车现在分别占用了一部分桥的资源。 A 要想过桥的话，需要 B 车让出桥面资源。

同理 B 车想要过桥，也需要 A 车让出桥面资源。两边的车都不倒车，结果造成互相等待对方让出桥面，但是谁也不让路，就会无休止地等下去。这种现象就是死锁。如果把汽车比做进程，桥面作为资源，那上述问题就描述为：

进程 A 占有资源 R1，等待进程 B 占有的资源R2；进程 B 占有资源 R2，等待进程 A 占有的资源 R1。而且资源 R1和 R2 只允许一个进程占用， 即：不允许两个进程同时占用。结果，两个进程都不能继续执行，若不采取其它措施，这种循环等待状况会无限期持续下去，就发生了进程死锁。

------

### 2.简要描述一下数据库的事务

事务是并发控制的基本单位。所谓的事务，它的根本是一个操作序列，这些操作都执行，或者都不执行，它是一个无法分割的工作单位。例如银行转账:从一个账户扣款并使另一个账户赠款，这两个操作要么都执行，要么都不执行，不能存在执行一半，否则会出现金额消失或者无中生有。所以我们能够把整个操作的过程，看成一个事务。

------

### 3.乐观锁和悲观锁的解释及其应用场景

- **悲观锁(Pessimistic Lock)**

  顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

- **乐观锁(Optimistic Lock)**

  顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于 write_condition 机制的其实都是提供的乐观锁。

- **使用场景**

  两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行 retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。
  问到悲观锁和乐观锁，面试官主要是想考查求职者对比使用数据库锁来保证多用户并发访问时数据库安全的问题。在回答这个问题的时候，可以从锁的名称来解析去两个锁的本质区别，然后面试官可能会问到两个锁那个更好，在回答框架或者某种技术那个更好的时候，我们要记住一点，就是没有最好的，只有最适合的。

  

---------------------------------

转载请注明原地址，宋德凌的博客：[http://CoderOfSong.github.io](http://CoderOfSong.github.io) 谢谢！