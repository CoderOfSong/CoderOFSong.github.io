---
layout: post
title: "Java面试题：数据库"
date: 2018-8-5 
description: "面试题 数据库"
tag: Java面试题 
---   

## Java面试题：数据库

------------------------------

### 1.delete与truncate区别

- delete语句执行删除的过程是每次从表中删除一行,并且同时将该行的删除操作作为事务记录在日志中保存以便进行回滚操作,不清空auto_increment记录数
- truncate则直接将表删除并重新建表,不会把单独的删除操作记录记入日志保存,删除行是不能恢复的,auto_increment将重置为0,效率比delete高

-----------------------------------------------

### 2.储存过程

1. 概念

   存储过程是一组为了完成特定功能的SQL语句集,经编译后存储在数据库中,用户通过指定存储过程的名字并给定`参数`(如果该存储过程带有参数)来调用执行它

2. 如何创建存储过程

   "pr_add"是个简单的MySQL存储过程,这个MySQL存储过程有两个int类型a,b的参数,返回和.

   ```sql
   drop procedure if exists pr_add;
   create procedure pr_add (a int , b int) begin declare c int;
   if a is null then set a = 0;
   end if;
   if b is null then set b = 0;
   end if;
   set c = a + b;
   select c as sum;
   ```

--------------------------------------------

### 3.索引

1. 概念

   索引是对数据库中一或多个列值的排序,帮助数据库高效获取数据的数据结构.假如我们用类比的方法,数据库中的索引就相当于书籍中的目录一样,当我们想找到书中某个知识点,我们就可以直接去目录中找而不是在书中每页找.

2. 分类

   > 普通索引
   >
   > 唯一索引
   >
   > 主键索引
   >
   > 全文索引

3. 优缺点

   1. **优点:**

      > 加快检索速度
      >
      > 唯一索引确保每行数据的唯一性
      >
      > 在使用索引的过程可以优化隐藏器,提高系统性能

   2. **缺点:**

      > 在对数据库修改时,要修改索引导致时间变长
      >
      > 增删改维护速度下降
      >
      > 占用物理和数据空间

4. 如何创建索引

   ```sql
   /*1.添加PRIMARY KEY（主键索引）*/
   ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` );
   /*添加UNIQUE(唯一索引)*/
   ALTER TABLE `table_name` ADD UNIQUE ( `column` )
   /*添加INDEX(普通索引)*/
   ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
   /*添加FULLTEXT(全文索引)*/
   ALTER TABLE `table_name` ADD FULLTEXT ( `column`)
   /*添加多列索引(扩展)*/
   ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`,`column3` )
   ```

-----------------------------------------------------

### 4.事务

1. 应用场景:**存在并发数据访问时才需要事务**

2. ACID四大特性

   1. **原子性(Atomicity):**

      整个事务中的所有操作,要么全部完成,要么全部不完成,不可能停滞在中间的某个环节.任何一项操作的失败都会导致整个事务的失败

   2. **一致性(Correspondence):**

      在事务开始之前和事务结束之后,数据库的完整性约束没有被破坏

   3. **隔离性(Isolation):**

      并发执行的事务彼此无法看到对方的中间状态

   4. **持久性(Durability):**

      在事务完成以后,该事务所对数据库所做的更改便持久的保存在数据库之中,并不会被回滚

3. 事务中的问题与隔离级别

   - **问题:**
     - **脏读:**一个事务读取到了另一个事务未提交的数据
     - **不可重复读:**一个事务中两次查询的数据不一致 --> 一个事务读到了另一个事务已提交的数据(update操作)
     - **虚读(幻读):**一个事务中两次查询的数据不一致 --> 一个事务读到了另一个事务已经提交的数据(insert操作)
   - **隔离级别(安全从低到高,性能从高到低):**
     - **读未提交:**也叫`脏读`,是事务可以读取其他事务未提交的数据.(**未解决任何问题**)
     - **读已提交:**在事务未提交之前所做的修改,其他事务是不可见的.(**解决脏读问题**)(`Oracle,SqlServer默认事务隔离级别`)
     - **可重复读:**保证同一事务中的多次相同的查询的结果是一致的.(**解决脏读,不可重复读问题**)(`MySQL默认事务隔离级别`)
     - **可串行化:**保证读取的范围内没有新的数据插入,比如事务第一次查询得到某个范围的数据,第二次查询也同样得到了相同范围的数据,中间没有新的数据插入到该范围中(**解决脏读,不可重复读,虚读(幻读)的问题**).

4. 如何进行事务管理

   `Connection`提供了事务处理的方法,通过调用setAutoCommit(false)可以设置手动提交事务;当事务完成后用commit()显式提交事务;如果在事务处理过程中发生异常则通过rollback()进行事务回滚.除此之外,从JDBC3.0中还引入了Savepoint(保存点)的概念,允许通过代码设置保存点并让事务回滚到指定的保存点.

---------------------------------------------

### 5.Oracle和MySQL的分页语句

1. Oracle是通过rownum分页的

   ```sql
   /*查询1-10*/
   select * from 
   	(select rownum r , a from tableA where rownum <= 10)
   where r > 0
   ```

2. MySQL是通过`limit`关键字分页

   ```sql
   /*查询1-10*/
   select * from tableA limit 0,10
   ```

---------------------------

### 6.Oracle经常用到的函数

```sql
Length() 	--长度
lower()  	--小写
upper()		--大写
to_date()	--转换日期
to_char()	--转化字符
Ltrim()		--去除左边空格
rtrim()		--去除右边空格
substr()	--取字串
add_month()	--增加或者减掉月份
to_number()	--转变为数字
```

----------------------------

### 7.Oracle高水位线

1. **什么是高水位线（High Water Mark)?**

   所有的oracle段（segments，在此，为了理解方便，建议把segment作为表的一个同义词）都有一个在段内容纳数据的上限，我们把这个上限称"为high water mark"或HM。这个HM是一个标记，用来说明已经有多少没有使用的数据块分配给这个segment。HWM通常增长的幅度为一次5个数据块，原则上HIRM只会增大，不会缩小，即使将表中的数据全部删除，HWM还是为原值，由于这个特点，使HRM很象一个水库的历史最高水位，这也就是HM的原始含义，当然不能说一个水库没水了，就说该水库的历史最高水位为0。但是如果我们在表上使用了truncate命令，则该表的HWM会被重新置为0。

2. **Oracle表段中的高水位线HWM**

   在0racle数据的存储中，可以把存储空间想象为一个水库，数据想象为水库中的水。水库中的水的位置有一条线叫做水位线，在0racle中，这条线被称为高水位线（High-warter mark,HWM)。在数据库表刚建立的时候，由于没有任何数据，所以这个时候水位线是空的，也就是说HRM为最低值。当插入了数据以后，高水位线就会上涨，但是这里也有一个特性，就是如果你采用delete语句删除数据的话，数据虽然被删除了，但是高水位线却没有降低，还是你刚才删除数据以前那么高的水位。也就是说，这条高水位线在日常的增删操作中只会上涨，不会下跌。

------------------------

### 8.数据库语句优化

> 1.对查询进行优化,应尽量避免全表扫描,首先应考虑在`where`及`order by`涉及的列上建立索引
>
> 2.应尽量避免在`where`子句中对字段进行`null`值判断,否则将导致引擎放弃使用索引而进行全表扫描
>
> 3.应尽量避免在`where`子句中使用`!=`或`<>`操作符,否则将导致引擎放弃使用索引而进行全表扫描
>
> 4.应尽量避免在`where`子句中使用`or`来连接条件,否则将导致引擎放弃使用索引而进行全表扫描
>
> 5.`in`和`not in`也要慎用,否则会导致全表扫描
>
> 6.索引并不是越多越好,索引固然可以提高相应的`select`的效率,但同时也降低了`insert`及`update`的效率,因为`insert`或`update`时有可能会重建索引,所以怎样建索引需要慎重考虑,是具体情况而定.一个表的索引数最好不要超过6个,若太多则应考虑一些不常使用到的列上建的索引是否有必要.
>
> 7.查询到的结果不要用`*`来查询所有字段,要明确指明结果字段
>
> 8.根据查询条件，建立索引，如果查询条件不止一个时，使用组合索引
>
> 9.在查询条件表达式的左侧尽量不要使用函数，否则素引失效
>
> 10.如果有like话，尽量避免%xxX%两侧都有%的条件，单侧%可以使用索引，
> 多侧不可以
>
> 11.建立索引时字段不能有null值

------------------

### 9.数据库优化

1. MySQL数据库优化有哪些?

   > 1. `EXPLAIN`你的`SELECT`查询
   > 2. 当只要一行数据时使用`LIMIT 1`
   > 3. 使用`ENUM`而不是`VARCHAR`
   > 4. 固定长度的表会更快
   > 5. 分库分表

2. Oracle数据库优化有哪些?

   > 1. 调整数据结构的设计
   > 2. 调整应用程序结构设计
   > 3. 调整数据库SQL语句
   > 4. 调整服务器内存分配
   > 5. 调整硬盘I/O
   > 6. 调整操作系统参数

--------------------------

*理论知识结束*

------------



----------------------------

持续更新中...

---------------------------------

转载请注明原地址，宋德凌的博客：[http://CoderOfSong.github.io](http://CoderOfSong.github.io) 谢谢！