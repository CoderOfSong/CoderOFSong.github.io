---
layout: post
title: "Java面试题"
date: 2018-8-5 
description: "Java基础知识 面试题"
tag: Java面试题
---   

## Java面试题一

---------------------------------------

## 基础

---------------------------

### 1. 说一下ArrayList底层实现方式

1. ArrayList 通过数组实现，一旦我们实例化 ArrayList 无参数构造函数默认 为数组初始化长度为 10    
2. add 方法底层实现如果增加的元素个数超过了 10 个，那么 ArrayList 底层会 新生成一个数组，长度为原数组的 1.5 倍+1，然后将原数组的内容复制到新数 组当中，并且后续增加的内容都会放到新数组当中。当新数组无法容纳增加的 元素时，重复该过程。是一旦数组超出长度，就开始扩容数组。扩容数组调用 的方法 Arrays.copyOf(objArr, objArr.length + 1);    

--------------------

### 2.说一下LinkedList底层实现方式

LinkedList 底层的数据结构是基于双向循环链表的，且头结点中不存放数据, 如下：    

![LinkedList实现一](https://i.imgur.com/VcoDqKV.png)

既然是双向链表，那么必定存在一种数据结构——我们可以称之为节点，节点 实例保存业务数据，前一个节点的位置信息和后一个节点位置信息，如下图所 示：    

![LinkedList数据结构](https://i.imgur.com/yBOwndE.png)

---------------------

### 3.说一下HashMap底层实现方式

HashMap 是由数组+链表组成

**put 方法底层实现:** 通过 key 的 hash 值%Entry[].length 得到该存储的下标位置，如果多个 key 的 hash 值%Entry[].length 值相同话就就会存储到该链表的后面。    

----------------------

### 4.关于HashMap面试题

- **“你用过 HashMap 吗？” “什么是 HashMap？你为什么用到它？”**    

  HashMap 可以接受 null 键值和值，而 Hashtable 则不能；

  HashMap 是非 synchronized所以HashMap 很快；

  以及 HashMap 储存的是键值对等等。    

- **“你知道 HashMap 的工作原理吗？” “你知道 HashMap 的 get()方法的工作原理 吗？”**    

  “HashMap 是基于 hashing 的原理，我们使 用 put(key, value)存储对象到 HashMap 中，使用 get(key)从 HashMap 中获取 对象。当我们给 put()方法传递键和值时，我们先对键调用 hashCode()方法， 返回的 hashCode 用于找到 bucket 位置来储存 Entry 对象。”这里关键点在于 指出， HashMap 是在 bucket 中储存键对象和值对象，作为 Map.Entry。这一点 有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅 只在 bucket 中存储值的话，你将不会回答如何从 HashMap 中获取对象的逻辑。    

- **“当两个对象的 hashcode 相同会发生什么？”**    

  “因为 hashcode 相同，所以它们的 bucket 位置相同， ‘碰撞’ 会发生。因为 HashMap 使用链表存储对象，这个 Entry(包含有键值对 的 Map.Entry 对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处 理碰撞的方法，这种方法是最简单的。

- **“如果两个键的 hashcode 相同，你如何获取值对象？”**    

  找到 bucket 位置之后，会调用 keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。    

  许多情况下，面试者会在这个环节中出错，因为他们混淆了 hashCode()和 equals()方法。因为在此之前 hashCode()屡屡出现，而 equals()方法仅仅在获 取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作 final 的对象，并且采用合适的 equals()和 hashCode()方法的话，将会减少碰 撞的发生，提高效率。不可变性使得能够缓存不同键的 hashcode，这将提高整 个获取对象的速度，使用 String， Interger 这样的 wrapper 类作为键是非常好 的选择。

- **“如果 HashMap 的大小超过了负载因子(load factor)定义的容量，怎么办？”** 

  默认的负载 因子大小为 0.75，也就是说，当一个 map 填满了 75%的 bucket 时候，和其它集 合类(如 ArrayList 等)一样，将会创建原来 HashMap 大小的两倍的 bucket 数 组，来重新调整 map 的大小，并将原来的对象放入新的 bucket 数组中。这个过 程叫作 rehashing，因为它调用 hash 方法找到新的 bucket 位置。    

- **“你了解重新调整 HashMap 大小存在什么问题吗？”**

  当重新调整 HashMap 大小的时候，存在条件竞争(race condition)，因为如果两个线程都发 现 HashMap 需要重新调整大小了，它们会同时试着调整大小。在调整大小的过 程中，存储在链表中的元素的次序会反过来，因为移动到新的 bucket 位置的时 候， HashMap 并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾 部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。

- **为什么 String, Interger 这样的 wrapper 类适合作为键？**

  String, Interger 这样的 wrapper 类作为 HashMap 的键是再适合不过了，而且 String 最为常用。因为 String 是不可变的，也是 final 的，而且已经重写了 equals()和 hashCode()方法了。其他的 wrapper 类也有这个特点。不可变性是 必要的，因为为了要计算 hashCode()，就要防止键值改变，如果键值在放入时和 获取时返回不同的 hashcode的话，那么就不能从 HashMap中找到你想要的对象。 不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个 field 声明成 final 就能保证 hashCode 是不变的，那么请这么做吧。因为获取对象的时候要 用到 equals()和 hashCode()方法，那么键对象正确的重写这两个方法是非常重 要的。如果两个不相等的对象返回不同的 hashcode 的话，那么碰撞的几率就会 小些，这样就能提高 HashMap 的性能。

- **我们可以使用自定义的对象作为键吗？**

  只要它遵守了 equals()和 hashCode()方法的定义规则，并且当对象插入到 Map 中之后将不会 再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件， 因为当它创建之后就已经不能改变了

- **我们可以使用 CocurrentHashMap 来代替 Hashtable 吗？**

  可以，因为CocurrentHashMap性能更加,而且HashTable已经被淘汰了,不要再新代码中应用它,也可从CocurrentHashMap分段锁回答。

#### 总结

- **HashMap 的工作原理**

  HashMap 基于 hashing 原理，我们通过 put()和 get()方法储存和获取对象。当 我们将键值对传递给 put()方法时，它调用键对象的 hashCode()方法来计算 hashcode，让后找到 bucket 位置来储存值对象。当获取对象时，通过键对象的 equals()方法找到正确的键值对，然后返回值对象。 HashMap 使用链表来解决 碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap 在 每个链表节点中储存键值对对象。    

- **当两个不同的键对象的 hashcode 相同时会发生什么** 

  它们会储存在同一个 bucket 位置的链表中。键对象的 equals()方法用来找到 键值对。 因为 HashMap 的好处非常多，我曾经在电子商务的应用中使用 HashMap 作为缓存。因为金融领域非常多的运用 Java，也出于性能的考虑，我们会经常用到 HashMap 和 ConcurrentHashMap。

--------------------------------------

### 5.ArrayList集合加入一万条数据，应该怎么提高效率？

因为 ArrayList 的底层是数组实现,并且数组的默认值是 10,如果插入 10000 条要不断的扩容,耗费时间,所以我们调用 ArrayList 的指定容量的构造 器方法 ArrayList(int size) 就可以实现不扩容,就提高了性能

---------------------------

### 6.IO和NIO的区别



--------------------------------------------

### 7.多线程的安全问题如何保证？

我们在考虑过线程安全问题的时候，要避免不必要的同步；过多的同步会造成死锁以及昂贵的锁竞争代价。除此以外，程序设计的时候，如果不得已面临线程安全的情况，要采取对应的措施；能保证线程的机制是锁机制、 AQS 机制，对象头补齐机制等；根据环境和特定的业务挑选最合适的方法。
我们常用的有三种，同步代码块，同步方法，同步锁

1. **同步代码块:**

   在代码块声明上 加上 synchronized

   ```java
   synchronized (锁对象) {
   	//可能会产生线程安全问题的代码
   }
   ```

   同步代码块中的锁对象可以是任意的对象；但多个线程时，要使用同一个锁对
   象才能够保证线程安全。

2. 同步方法：

   在方法声明上加上 synchronized

   ```java
   public synchronized void method(){
   	//可能会产生线程安全问题的代码
   }
   ```

   同步方法中的锁对象是 this
   静态同步方法: 在方法声明上加上 static synchronized
   静态同步方法中的锁对象是 类名.class

3. 同步锁

   Lock 接口提供了与 synchronized 关键字类似的同步功能，但需要在使用时手
   动获取锁和释放锁。

除了 sync 锁之外， Java 提供了一些线程安全容器，要活用这些容器。
对于 Java 而言，线程安全工具已经足够多了。基本上能满足需求。

---------------------

### 8.反射怎么理解？说一下反射经典的应用    

反射是什么呢？当我们的程序在运行时，需要动态的加载一些类这些类可 能之前用不到所以不用加载到 jvm，而是在运行时根据需要才加载，这样的好 处对于服务器来说不言而喻，举个例子我们的项目底层有时是用 mysql，有时 用 oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假 设 com.java.dbtest.myqlConnection， com.java.dbtest.oracleConnection 这两个类我们要用，这时候我们的程序就写得比较动态化，通过 Class tc = Class.forName("com.java.dbtest.TestConnection");通过类的全类名让 jvm 在服务器中找到并加载这个类，而如果是 oracle 则传入的参数就变成另一个 了。这时候就可以看到反射的好处了，这个动态性就体现出 java 的特性了！举 个例子，使用 spring 中会发现当你配置各种各样的 bean 时，是以配置文件的 形式配置的，你需要用到哪些 bean 就配哪些， spring 容器就会根据你的需求 去动态加载，你的程序就能健壮地运行。

----------------------------

## WEB

--------------------------

###1.session和cookie我们一般用来做什么?

1. cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数 据。跟服务器没啥关系，仅仅是浏览器实现的一种数据存储功能。 session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道 当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他 就是张三。 
2. session 也是类似的道理，服务器要知道当前发请求给自己的是 谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识” ，然 后客户端每次向服务器发请求的时候，都带上这个“身份标识” ，服务器就知 道这个请求来自于谁了。至于客户端怎么保存这个“身份标识” ，可以有很多 种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。
3.  cookie 存于客户端。 session 存于服务器端。
4. 服务器鉴别 session 需要至少从 客户端传来一个 session_id， session_id 通常存于 cookie 中。所以在工程上 session 离了 cookie 基本没法用，但是 cookie 可以单独使用，不过 cookies 是明文存储，安全性很低，只使用 cookie 的话盗取了 cookie 基本就获取了用 户所有权限。    

**项目中登录的模块结合 cookie**    

当会员需要登录的时候，首先进入的是“登录页面”，输入用户名、密码、验 证码进行登录，进入单点登录系统（Controller） Service Mapper DB 提交登录页面，用户信息被提交到单点登录系统进行校验。如果登陆信息不正 确，校验错误，将错误的登陆信息进行回显返回给用户，重新登录。验证通 过，就将用户信息保存到 redis 中，并且生成 token 作为一个标识，并将 token 保存到 cookie 里面，发送给用户浏览器，下次请求的时候就会带回来， 获取 cookie 里面的 token，根据 token 再去 redis 中查询对应的用户信息。登 录成功后将重定向到登录之前的访问页面。

------------------------------

### 2.Http协议中有哪些请求方式?

- **GET：** 用于请求访问已经被 URI（统一资源标识符）识别的资源，可以通过 URL
  传参给服务器
- **POST：**用于传输信息给服务器，主要功能与 GET 方法类似，但一般推荐使用
  POST 方式。
- **PUT：** 传输文件，报文主体中包含文件内容，保存到对应 URI 位置。
- **HEAD：** 获得报文首部，与 GET 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效。
- **DELETE：**删除文件，与 PUT 方法相反，删除对应 URI 位置的文件。
- **OPTIONS：**查询相应 URI 支持的 HTTP 方法。

-------------------------------

### 3.get 与 post 请求区别?

1. get 重点在从服务器上`获取资源`， post 重点在向服务器`发送数据`；
2. get 传输数据是通过 URL 请求，以 field（字段） = value 的形式，置于 URL 后，并用"?"连接，多个请求数据间用"&"连接，如http://127.0.0.1/Test/login.action?name=admin&password=admin，这个过程用户是可见的；
   post 传输数据通过 Http 的 post 机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；
3. Get 传输的数据量小，因为受 URL 长度限制，但效率较高；
   Post 可以传输大量数据，所以上传文件时只能用 Post 方式；
4. get 是不安全的，因为 URL 是可见的，可能会泄露私密信息，如密码等；
   post 较 get 安全性较高；
5. get 方式只能支持 ASCII 字符，向服务器传的中文字符可能会乱码。
   post 支持标准字符集，可以正确传递中文字符。

---------------------

### 4.常见 Http 协议状态?

200：请求被正常处理
204：请求被受理但没有资源可以返回
206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行 GET 方
法，相应报文中通过 Content-Range 指定范围的资源。
301：永久性重定向
302：临时重定向
303：与 302 状态码有相似功能，只是它希望客户端在请求一个 URI 的时候，能
通过 GET 方法重定向到另一个 URI 上
304：发送附带条件的请求时，条件不满足时返回，与重定向无关
307：临时重定向，与 302 类似，只是强制要求使用 POST 方法
400：请求报文语法有误，服务器无法识别
401：请求需要认证
403：请求的对应资源禁止被访问
404：服务器无法找到对应资源
500：服务器内部错误
503：服务器正忙

-------------------

### 5.Servlet 的执行流程。 doGet 和 doPost 的区别？

1. Servlet 的执行流程也就是 servlet 的生命周期，当服务器启动的时候生命周期开始，然后通过 init()*启动顺序根据 web.xml 里的 startup-on-load 来确定加载顺序*方法初始化 servlet，再根据不同请求调用 doGet 或 doPost 方法，最后再通过 destroy()方法进行销毁。
2. doGet 和 doPost 都是接受用户请求的方法， doGet 处理 get 请求， doPost 处理post 请求， doGet 用于地址栏提交， doPost 用于表单提交，在页面提交数据时， get 的数据大小有限制 4k， post 没有限制， get 请求提交的数据会在地址栏显示， post 不显示，所以 post 比 get 安全.

-------------------------------

### 6.Jsp 的重定向和转发的流程有什么区别？

1. 重定向是`客户端`行为，转发是`服务器`端行为
2. 重定向时服务器产生两次请求，转发产生一次请求，重定向时可以转发到项目以外的任何网址，转发只能在当前项目里转发
3. 重定向会导致 request 对象信息丢失。转发则不会
4. 转发的 url 不会变,request.getRequestDispatch（） .forward()
5. 重定向的 url 会改变,response.getRedirect();

-----------------------------------------------------

### 7.Jsp 的九大内置对象，三大指令，七大动作的具体功能？

1. **JSP 九大内置对象:**

   > - pageContext ：只对当前 jsp 页面有效，里面封装了基本的 request 和session 的对象
   > - Request ：对当前请求进行封装
   > - Session ：浏览器会话对象，浏览器范围内有效
   > - Application ：应用程序对象，对整个 web 工程都有效
   > - Out ：页面打印对象，在 jsp 页面打印字符串
   > - Response ：返回服务器端信息给用户
   > - Config ：单个 servlet 的配置对象，相当于 servletConfig 对象
   > - Page ：当前页面对象，也就是 this
   > - Exception ：错误页面的 exception对象，如果指定的是错误页面，这个就是异常对象

2. **三大指令：**

   > - Page ：指令是针对当前页面的指令
   > - Include ：用于指定如何包含另一个页面
   > - Taglib ：用于定义和指定自定义标签

3. **七大动作：**

   > - Forward，执行页面跳转，将请求的处理转发到另一个页面
   > - Param ：用于传递参数
   > - Include ：用于动态引入一个 jsp 页面
   > - Plugin ：用于下载 javaBean 或 applet 到客户端执行
   > - useBean ：使用 javaBean
   > - setProperty ：修改 javaBean 实例的属性值
   > - getProperty ：获取 javaBean 实例的属性值

----------------------------------------------

### 8.request ，response，session 和 application 是怎么用的？

- Request 是客户端向服务端发送请求
- Response 是服务端对客户端请求做出响应
- Session 在 servlet 中不能直接使用，需要通过 getSession()创建，如果没有设定它的生命周期，或者通过 invildate()方法销毁，关闭浏览器 session 就会消失
- Application 不能直接创建，存在于服务器的内存中，由服务器创建和销毁

----------------------------------------

## 数据库

----------------------------------

### 1. 说一下对多线程死锁的理解，举个例子，说一下什么情况下会出现死锁？

举个生活中的例子：有一座桥很窄，一次只能通过一辆汽车，可现在有 A 和B 两辆汽车分别从桥的两端已经驶进了桥，也就是两辆车现在分别占用了一部分桥的资源。 A 要想过桥的话，需要 B 车让出桥面资源。

同理 B 车想要过桥，也需要 A 车让出桥面资源。两边的车都不倒车，结果造成互相等待对方让出桥面，但是谁也不让路，就会无休止地等下去。这种现象就是死锁。如果把汽车比做进程，桥面作为资源，那上述问题就描述为：

进程 A 占有资源 R1，等待进程 B 占有的资源R2；进程 B 占有资源 R2，等待进程 A 占有的资源 R1。而且资源 R1和 R2 只允许一个进程占用， 即：不允许两个进程同时占用。结果，两个进程都不能继续执行，若不采取其它措施，这种循环等待状况会无限期持续下去，就发生了进程死锁。

-----------------------------------------

### 2.简要描述一下数据库的事务

事务是并发控制的基本单位。所谓的事务，它的根本是一个操作序列，这些操作都执行，或者都不执行，它是一个无法分割的工作单位。例如银行转账:从一个账户扣款并使另一个账户赠款，这两个操作要么都执行，要么都不执行，不能存在执行一半，否则会出现金额消失或者无中生有。所以我们能够把整个操作的过程，看成一个事务。

------------------------------------------

### 3.乐观锁和悲观锁的解释及其应用场景

- **悲观锁(Pessimistic Lock)**

  顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

- **乐观锁(Optimistic Lock)**

  顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于 write_condition 机制的其实都是提供的乐观锁。

- **使用场景**

  两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行 retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。
  问到悲观锁和乐观锁，面试官主要是想考查求职者对比使用数据库锁来保证多用户并发访问时数据库安全的问题。在回答这个问题的时候，可以从锁的名称来解析去两个锁的本质区别，然后面试官可能会问到两个锁那个更好，在回答框架或者某种技术那个更好的时候，我们要记住一点，就是没有最好的，只有最适合的。

-----------------------------------

## 框架

---------------------------------------------

### 1.hibernate的get()和load()方法的去别?

- **返回值：**

  get()返回的是查询出来的实体对象，而 load()查询出来的是一个目标实体的代理对象。

- **查询时机：**

  get()在调用的时候就立即发出 SQL 语句查询，而 load()在访问非 ID 属性的时候才会发出查询语句并且将被代理对象 target 填充上，但是如果这个动作发生在 Session 被关闭后的话就会抛出 LazyInitializationException。

- **查询结果为空时：**

  get()抛出 NullPointerException
  load()抛出 ObjectNotFoundException

-------------------------------------

### 2.描述spring中的编程式事务处理和声明式事务处理

编程式事务需要你在代码中直接加入处理事务的逻辑,可能需要在代码中显式调beginTransaction()、 commit()、 rollback()等事务管理相关的方法,如在执行 a 方法时候需要事务处理,你需要在 a 方法开始时候开启事务,处理完后。在方法结束时候,关闭事务。

声明式的事务的做法是在 a 方法外围添加注解或者直接在配置文件中定义,a 方法需要事务处理,在spring 中会通过配置文件在 a 方法前后拦截,并添加事务。

**二者区别：**编程式事务侵入性比较强，但处理粒度更细。

-----------------------------------

### 3.spring 设置为单例，线程安全问题怎么解决？

spring 的单例和我们设计模式中的单例还是有些区别的，设计模式中的单例是在整个应用中只存在一个单例，而 spring 中的单例是存在 IOC 容器中只有一个实例， spring 中的单例并不会影响到应用的并发访问，通常我们 spring中的线程安全问题是指的在业务逻辑中的那个问题， ThreadLocal 则从另一个角度来解决多线程的并发访问。 

ThreadLocal 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。 ThreadLocal 提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。

-------------------------------------

### 4.struts 可以是单例的吗？ 为什么？

在 Struts2 中 action 必须为多例，主要原因在于请求数据和返回数据大部分封装到了 action 中，用于实例化变量，这样以来，如果将 action 设置成单例模式，则多个线程访问的时候，就会共享这些数据，从而引起数据混乱或者线程安全问题！

------------------------

### 5.SpringMVC 工程流程

1. 用户向服务器发送请求，请求被 Spring 前端控制ServeltDispatcherServlet 捕获；
2. DispatcherServlet 对请求 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回；
3. DispatcherServlet 根据获得的 Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得 HandlerAdapter 后，此时将开始执行拦截器的 preHandler(...)方法）
4. 提取 Request 中的模型数据，填充 Handler 入参，开始执行 Handler（Controller)。 在填充 Handler 的入参过程中，根据你的配置， Spring 将帮你做一些额外的工作：
   1. **HttpMessageConveter：**将请求消息（如 Json、 xml 等数据）转换成一个对象，将对象转换为指定的响应信息
   2. **数据转换：**对请求消息进行数据转换。如 String 转换成 Integer、 Double 等
   3. **数据根式化：**对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等
   4. **数据验证：** 验证数据的有效性（长度、格式等），验证结果存储到BindingResult 或 Error 中
5. Handler 执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象；
6. 根据返回的 ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的 ViewResolver)返回给 DispatcherServlet ；
7. ViewResolver 结合 Model 和 View，来渲染视图
8. 将渲染结果返回给客户端

---------------------

### 6.hibernate 的懒加载有几种禁用方法？

在 Hibernate 框架中，当我们要访问的数据量过大时，明显用缓存不太合适，因为内存容量有限 ，为了减少并发量，减少系统资源的消耗，这时Hibernate 用懒加载机制来弥补这种缺陷，但是这只是弥补而不是用了懒加载总体性能就提高了。

我们所说的懒加载也被称为延迟加载，它在查询的时候不会立刻访问数据库，而是返回代理对象，当真正去使用对象的时候才会访问数据库。

1. 使用代理对象： Hibernate.initialize("代理对象");
2. 在需要禁用懒加载的映射文件中显示的加入 lazy = "false"
3. 使用 openSessionInView【需要借助于过滤器】 需要在 web.xml 文件中配置

----------------------

### 7.Hibernate 工作原理及为什么要用？

**原理:**

1. 读取并解析配置文件
2. 读取并解析映射信息
3. 创建 SessionFactory
4. 打开 Sesssion
5. 创建事务 Transation
6. 持久化操作
7. 提交事务
8. 关闭 Session
9. 关闭 SesstionFactory

**为什么要用**

1. 对 JDBC 访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。
2. Hibernate 是一个基于 JDBC 的主流持久化框架，是一个优秀的 ORM 实现，他很大程度的简化 DAO 层的编码工作。
3. hibernate 使用 Java 反射机制，而不是字节码增强程序来实现透明性。
4. hibernate 的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。

------------------

## 实际开发

-----------------------------

### 1.简要描述一下数据库的事务

事务是并发控制的基本单位。所谓的事务，它的根本是一个操作序列，这些操作都执行，或者都不执行，它是一个无法分割的工作单位。
**例如银行转账:**从一个账户扣款并使另一个账户赠款，这两个操作要么都执行，要么都不执行，不能存在执行一半，否则会出现金额消失或者无中生有。所以我们能够把整个操作的过程，看成一个事务。

---------------------

### 2.如果项目已经上线了你，但是出现了问题。 主要是怎么解决，或者你们怎样找出问题所在的（日志方向），这块你接触过吗？

通过引用 log4j 日志包来查看，在每个类中引用相应的日志来记录，在服务器中留出专门的空间来存储日志，后缀为.log 的文件，出现的错误会存储到日志文件中，当我们需要查看的时候通过编译软件来查看。

---------------------------------

### 3.是否了解工作流?

以请假为例，现在大多数公司的请假流程是这样的:

```
员工打电话（或网聊）向上级提出请假申请——>上级口头同意——>上级将请假记录下来——>月底将请 假记录上交公司——>公司将请假录入电脑
```

采用工作流技术的公司的请假流程是这样的:

```
员工使用账户登录系统——>点击请假——>上级登录系统点击允许
```

就这样，一个请假流程就结束了
工作流系统，实现了工作流程的自动化，提高了企业运营效率、改善企业资源利用、提高企业运作的 灵活性和适应性、提高量化考核业务处理的效率、减少浪费
工作流可以参考 OA 系统，就是工作流程的执行过程。

------------------------------

### 4.使用SVN时发生冲突,如何解决?

1. 放弃自己的更新，使用 svn revert（回滚），然后提交。在这种方式下不需要使用 svn resolved（解决）
2. 放弃自己的更新，使用别人的更新。使用最新获取的版本覆盖目标文件，执行 resolved filename 并提交(选择文件—右键—解决)。
3. 手动解决：冲突发生时，通过和其他用户沟通之后，手动更新目标文件。然后执行 resolved filename 来解除冲突，最后提交。
4. 解决冲突：首先应该从版本库更新版本，然后去解决冲突，冲突解决后要执行svn resolved（解决），然后在签入到版本库。在冲突解决之后，需要使用svn resolved（解决）来告诉 subversion 冲突解决，这样才能提交更新。

-------------------------

### 5.redis 的 hash 类型在项目中的使用场景

我们在开发中常用 redis 存储五种数据类型
`String` , `Hash` , `List` , `Set` , `Zset(sorted set)`
关于 hash 在我们实际开发中的应用，我以存储用户信息为例。

- 第一种： key： userID； value： username； age； birthday

  第一种将用户 ID 作为查找 key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，避免产生脏数据。

- 第二种： key： userID+name value： name

  key： userID+age value： age
  key： userID+birthday value： birthday；
  第二种方法是这个用户信息对象有多少成员就存成多少个 key-value 对儿，用用户 ID+对应属性的名称作为唯一标识来取得对应属性的值，虽然省去了序列化开销和并发问题，但是用户 ID 为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。我们采取 hashmap 方法存储解决了上述两个问题，在存储用户信息的时候， key依旧是 userID，但是 value 值却是一个 map， map 中依旧存在 key 和 value；

  key 是姓名标签，对应的 value 是具体的姓名；如果需要修改姓名值时，只加用 userID+field（姓名）就可以修改姓名值了。这样操作不需要重复存储数据，也不需要考虑并发保护问题。

-------------------

持续更新中...

-------------------------------

转载请注明原地址，宋德凌的博客：[http://CoderOfSong.github.io](http://CoderOfSong.github.io) 谢谢！